<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Latent Demo</title>
  <style>
    html, body {
      margin: 0;
      height: 100%;
      background: #ffffff;
      display: flex;
      align-items: center;
      justify-content: center;
      overflow: hidden;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
    }
    canvas { display: block; }
    #info {
      position: absolute;
      bottom: 40px;
      left: 50%;
      transform: translateX(-50%);
      color: #6b7280;
      font-size: 11px;
      font-weight: 400;
      letter-spacing: 3px;
      text-transform: uppercase;
      z-index: 100;
      opacity: 0.5;
    }
  </style>
</head>
<body>
  <div id="info">Latent Space Visualization</div>
  <script type="module">
    // Check if embedded
    const urlParams = new URLSearchParams(window.location.search);
    const isEmbedded = urlParams.get('embed') === 'true';

    // Hide info text when embedded
    if (isEmbedded) {
      document.getElementById('info').style.display = 'none';
    }
  </script>
  <script type="module">
    import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.164/build/three.module.js';

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0xffffff);

    const camera = new THREE.PerspectiveCamera(50, innerWidth / innerHeight, 0.1, 1000);
    camera.position.set(0, 0, 5);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(innerWidth, innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    document.body.appendChild(renderer.domElement);

    // Stretched sphere within sphere - vertical stacked pods
    const group = new THREE.Group();

    // Inner sphere material (darker, denser)
    const innerMaterial = new THREE.MeshBasicMaterial({
      color: 0x3a3a3a,
      wireframe: true,
      transparent: true,
      opacity: 0.85
    });

    // Outer sphere material (lighter, more transparent)
    const outerMaterial = new THREE.MeshBasicMaterial({
      color: 0x6a6a6a,
      wireframe: true,
      transparent: true,
      opacity: 0.5
    });

    // Create 3 stacked pod segments
    const segments = [
      { y: 1.2, innerScale: 0.4, outerScale: 0.7, stretch: 1.8 },
      { y: 0, innerScale: 0.5, outerScale: 0.9, stretch: 2.0 },
      { y: -1.3, innerScale: 0.45, outerScale: 0.8, stretch: 1.9 }
    ];

    segments.forEach(seg => {
      // Inner sphere - round
      const innerGeometry = new THREE.SphereGeometry(seg.innerScale, 32, 32);
      const innerSphere = new THREE.Mesh(innerGeometry, innerMaterial);
      innerSphere.scale.y = seg.stretch;
      innerSphere.position.y = seg.y;
      group.add(innerSphere);

      // Outer sphere - stretched
      const outerGeometry = new THREE.SphereGeometry(seg.outerScale, 32, 32);
      const outerSphere = new THREE.Mesh(outerGeometry, outerMaterial);
      outerSphere.scale.y = seg.stretch;
      outerSphere.position.y = seg.y;
      group.add(outerSphere);
    });

    scene.add(group);

    // Subtle lighting
    const ambientLight = new THREE.AmbientLight(0xffffff, 1);
    scene.add(ambientLight);

    // Physics-based interaction
    let velocity = { x: 0, y: 0 };
    let rotation = { x: 0.3, y: 0.5 };
    let mouseX = 0, mouseY = 0;
    let isDragging = false;
    let previousMouseX = 0, previousMouseY = 0;

    // Mouse drag interaction
    renderer.domElement.addEventListener('mousedown', (e) => {
      isDragging = true;
      previousMouseX = e.clientX;
      previousMouseY = e.clientY;
      renderer.domElement.style.cursor = 'grabbing';
    });

    document.addEventListener('mousemove', (e) => {
      if (isDragging) {
        const deltaX = e.clientX - previousMouseX;
        const deltaY = e.clientY - previousMouseY;

        velocity.x = deltaY * 0.005;
        velocity.y = deltaX * 0.005;

        previousMouseX = e.clientX;
        previousMouseY = e.clientY;
      }
    });

    document.addEventListener('mouseup', () => {
      isDragging = false;
      renderer.domElement.style.cursor = 'grab';
    });

    renderer.domElement.style.cursor = 'grab';

    // Touch support
    let touchStartX = 0, touchStartY = 0;

    renderer.domElement.addEventListener('touchstart', (e) => {
      isDragging = true;
      touchStartX = e.touches[0].clientX;
      touchStartY = e.touches[0].clientY;
    });

    renderer.domElement.addEventListener('touchmove', (e) => {
      if (isDragging && e.touches.length > 0) {
        const deltaX = e.touches[0].clientX - touchStartX;
        const deltaY = e.touches[0].clientY - touchStartY;

        velocity.x = deltaY * 0.005;
        velocity.y = deltaX * 0.005;

        touchStartX = e.touches[0].clientX;
        touchStartY = e.touches[0].clientY;
      }
    });

    renderer.domElement.addEventListener('touchend', () => {
      isDragging = false;
    });

    function animate() {
      requestAnimationFrame(animate);

      // Apply velocity (with damping for realistic physics)
      if (!isDragging) {
        velocity.x *= 0.95;
        velocity.y *= 0.95;
      }

      rotation.x += velocity.x;
      rotation.y += velocity.y;

      // Gentle auto-rotation when idle
      if (!isDragging && Math.abs(velocity.x) < 0.001 && Math.abs(velocity.y) < 0.001) {
        rotation.y += 0.003;
      }

      // Apply rotation
      group.rotation.x = rotation.x;
      group.rotation.y = rotation.y;

      renderer.render(scene, camera);
    }
    animate();

    window.addEventListener('resize', () => {
      camera.aspect = innerWidth / innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(innerWidth, innerHeight);
    });
  </script>
</body>
</html>
